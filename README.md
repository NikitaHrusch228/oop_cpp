Лабораторная работа 1:

Реализовать идиому «умный указатель» для обеспечения автоматического управления 
памятью, показать эффективность полученной реализации (отсутствие утечек). 
Использование стандартных реализаций (например, STL) запрещено, кроме сравнительного 
тестирования. Относящиеся к реализации умных указателей классы должны быть 
шаблонными, а также должна корректно поддерживаться подтипизация шаблонных 
аргументов.

Реализован первый из предлагаемых вариантов: класс 
SmrtPtr<T>, отвечающий за подсчет ссылок на указываемый объект и удаление этого 
объекта, когда число ссылок достигает 0;

Лабораторная работа 2:

Требуется написать программу на C++ для сравнения различных алгоритмов 
сортировки. Написать краткое техническое задание (ТЗ). Выполнить реализацию. Написать 
для нее тесты

Sequence.h - Тут реализуем интерфейс(абстрактный класс) для последовательностей. Взяли методы такие как:
Создание подпоследовательности из нулей заданной длины, получение подпоследовательности из последовательности по индексам
Получение элемента первого, последнего, по индексу, длины, добавление элемента, вставка элемента по индексу, вывод элемента
Сортировка, применяемая к объекту - пузырёк, быстрая, шел

Node.h - Тут реализуем класс узла/ячейки
Хотим реализовать функционал для обращения к элементу
Создаём 3 поля - указатель на предыдущий объект, указатель на следующий объект, дата в ячейке
Добавляем перегрузку операторов на разыменовывание, сравнение узлов с нулевым состоянием, сравнение узлов по дате, вывод в поток

comparison.h - Здесь описываем компараторы, которые используем потом в сортировках

ISorter.h - Тут реализуем интерфейс ISorter и 3 класса-сортировщика - пузырьком, быстрая, сортировка Шелла

LinkedList.h - Тут реализуем шаблонный двусвязный список. Взяли методы такие как:
Добавление элементов в конец, в начало, по индексу. Удаление элементов с конца, с начала, по индексу.
Доступ к элементам, Смена элементов местами, возвращение подсписка, объединение списков

LinkedListSequence.h -Тут реализуем класс, который последовательность элементов на основе двусвязного списка. Наследник класса Sequence<T>
Реализованы методы: Доступ к элементам, вставка элементов, работа с подпоследовательностями, сортировки

ArraySequence.h - Тут реализуем класс последовательности на основе динамического массива
Реализованы следующие методы:
      Создание пустой последовательности, Создание последовательности с каким-то количеством нулевых элементов
      Объединение текущей последовательности с другой, Возвращает новую последовательность из элементов из интервала
      Создание последовательности из массива, Возвращение элемента по списку, добавление элемента в конец, добавление элемента в начало
      Вставка элемента на определённую позицию, Получение первого элемента, Получение последнего элемента

DynamicArray.h - Тут реализуем класс динамического массива
 В данном случае класс имеет 3 поля - указатель на первый элемент, размер, наполненность
 Реализованы следующие методы: 
    Смена элементов, Конструктор по умолчанию, Деструктор, Конструктор с числом элементов,
    Копирование элементов из переданного массива частично, Копирование элементов из переданного массива полностью
    Операции перераспределения памяти, Получене элемента по индексу, Установка значения по индексу
    Добавление элемента в конец, добавление элемента в начало, вывод элемента, Получения размера
