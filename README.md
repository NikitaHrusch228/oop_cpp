## Лабораторная работа 1:

Реализовать идиому «умный указатель» для обеспечения автоматического управления 
памятью, показать эффективность полученной реализации (отсутствие утечек). 
Использование стандартных реализаций (например, STL) запрещено, кроме сравнительного 
тестирования. Относящиеся к реализации умных указателей классы должны быть 
шаблонными, а также должна корректно поддерживаться подтипизация шаблонных 
аргументов.

Реализован первый из предлагаемых вариантов: класс 
SmrtPtr<T>, отвечающий за подсчет ссылок на указываемый объект и удаление этого 
объекта, когда число ссылок достигает 0;

## Лабораторная работа 2:

Требуется написать программу на C++ для сравнения различных алгоритмов 
сортировки. Написать краткое техническое задание (ТЗ). Выполнить реализацию. Написать 
для нее тесты

**Sequence.h** - Тут реализуем интерфейс(абстрактный класс) для последовательностей. Взяли методы такие как:
Создание подпоследовательности из нулей заданной длины, получение подпоследовательности из последовательности по индексам
Получение элемента первого, последнего, по индексу, длины, добавление элемента, вставка элемента по индексу, вывод элемента
Сортировка, применяемая к объекту - пузырёк, быстрая, шел

**Node.h** - Тут реализуем класс узла/ячейки
Хотим реализовать функционал для обращения к элементу
Создаём 3 поля - указатель на предыдущий объект, указатель на следующий объект, дата в ячейке
Добавляем перегрузку операторов на разыменовывание, сравнение узлов с нулевым состоянием, сравнение узлов по дате, вывод в поток

**comparison.h** - Здесь описываем компараторы, которые используем потом в сортировках

**ISorter.h** - Тут реализуем интерфейс ISorter и 3 класса-сортировщика - пузырьком, быстрая, сортировка Шелла

**LinkedList.h** - Тут реализуем шаблонный двусвязный список. Взяли методы такие как:
Добавление элементов в конец, в начало, по индексу. Удаление элементов с конца, с начала, по индексу.
Доступ к элементам, Смена элементов местами, возвращение подсписка, объединение списков

**LinkedListSequence.h** -Тут реализуем класс, который последовательность элементов на основе двусвязного списка. Наследник класса Sequence<T>
Реализованы методы: Доступ к элементам, вставка элементов, работа с подпоследовательностями, сортировки

**ArraySequence.h** - Тут реализуем класс последовательности на основе динамического массива
Реализованы следующие методы:
      Создание пустой последовательности, Создание последовательности с каким-то количеством нулевых элементов
      Объединение текущей последовательности с другой, Возвращает новую последовательность из элементов из интервала
      Создание последовательности из массива, Возвращение элемента по списку, добавление элемента в конец, добавление элемента в начало
      Вставка элемента на определённую позицию, Получение первого элемента, Получение последнего элемента

**DynamicArray.h** - Тут реализуем класс динамического массива
 В данном случае класс имеет 3 поля - указатель на первый элемент, размер, наполненность
 Реализованы следующие методы: 
    Смена элементов, Конструктор по умолчанию, Деструктор, Конструктор с числом элементов,
    Копирование элементов из переданного массива частично, Копирование элементов из переданного массива полностью
    Операции перераспределения памяти, Получене элемента по индексу, Установка значения по индексу
    Добавление элемента в конец, добавление элемента в начало, вывод элемента, Получения размера

## Лабораторная работа 3

Требуется написать программу на C++ для сравнения различных алгоритмов поиска. Сравнение 
алгоритмов должно производиться на одной из приведенных задач, связанных с обработкой 
информации. Написать краткое техническое задание (ТЗ). Выполнить реализацию. Написать 
для нее тесты. Реализовать пользовательский интерфейс

**person.h** - Тут реализуем класс Person, который хранит информацию о человеке и реализует методы для доступа к имени, фамилии, отчеству, дате рождения, возрасту. Также реализуем перегрузку операторов.

**DynamicArray** - Тут реализуем шаблонный класс DynamicArray, представляющий из себя динамический массив. Содержит конструкторы по умолчанию, с размером, копирование данных из существующего массива, копирование части массива, копирование существующего массива, также содержит методы доступа по индексу, измененение по индексу, возвращение текущего массива, функцию изменения размера и перегрузки операторов

**binary_tree.h** - Тут реализуем шаблонный класс BinaryTree (бинарное дерево поиска). Реализуемая структура "узла" состоит из указателей на родительский узел, левого и правого потомков, а также само хранимое значение. Поля класса состоят из корня, количества элементов и компаратор. Реализован деструктор, функция добавления, поиска, удаления элемента, поиска минимума и максимума, проверка наличия элемента и вывод всего дерева.

**set.h** - этот код реализует шаблонный класс Set, основанный на BinaryTree. Реализован конструктор копирования и конструктор с элементов и функцией сравнения, деструктор. Реализованы методы добавления, удаления, вывода, проверки наличия элемента, получения размера.

**Matrix** - реализует шаблонный класс Matrix, где поля есть: элементы(последовательность последовательностей), количество строк, количество столбцов. Реализованы конструкторы, деструктор и методы основных операций: сложение умножение на скаляр, умножение матриц. Реализованы функции получения нормы матрицы, вывод матрицы

**dictionary.h** - реализует шаблонный класс Dictionary - хранит пары в бинарном дереве, также реализован вспомогательный класс PairKE, хранящий пару ключ-значение. Реализован конструктор, а также реализованы методы: добавление элемента, получение значения по ключу, проверка наличия ключа, удаление элемента, изменение значения, вывод содержимого.

**histogram.h** - реализует класс Histogram для анализа распределения числовых параметров объекта класса Person. Поля - словарь с началами интервалов +  количеством людей; указатель на метод класса Person, возвращаемый анализируемый параметр. Реализован конструктор, деструктор. Реализованы методы получения количества людей в интервале, получения числа интервалов, вывод гистограммы.

**index.h** - реализует шаблонный класс IndexDictionary, что есть индексированный словарь для быстрого поиска объектов Person по заданному параметру. Поля - словарь + указатель на метод класса. Реализован конструктор. Реализованы основные методы: получение объекта по ключу, проверка наличия ключа, получение количества элементов, вывод содержимого.

**linkedList.h** - реализует шаблонный класс LinkedList связный список. Реализуем структуру "узел" - поля представляют собой данные в узле + указатель на следующий узел. Поля самого класса - указатель на первый узел + количество элементов. Реализованы конструкторы по умолчанию, конструктор из массива, конструктор с заданным параметром, конструктор копирования, деструктор. Реализованы основные методы - Доступ к элементам, изменение элементов, вставка и удаление элементов, информация о списке.

**sparse_matrix.h** - реализует шаблонный класс SparseMatrix, т.е. разреженная матрица. Реализован вспомогательный класс Pair - состоит из двух полей + реализованы геттеры, сеттеры, операторы сравнения. Реализован основной класс, поля - ненулевые элементы + количество строк + количество столбцов. Реализованы конструкторы из обычной матрицы, с заданными параметрами. Реализованы методы - установка и получение значений, работа с нулями, информация о матрице, вывод, конвертация в обычную матрицу.

**sortFunction.h** - реализует набор алгоритмов сортировки для абстрактной последовательности. Реализованы функции сравнения, проверки отсортированности, измерения времени сортировки. Реализованы алгоритмы сортировки - bubble sort, merge sort, quick sort, bogo sort.

## Лабораторная работа 4

Написать программу на C++, реализующую алгоритмы (поиска) на графах. 

**linkedList.h** - реализует шаблонный класс LinkedList связный список. Реализуем структуру "узел" - поля представляют собой данные в узле + указатель на следующий узел. Поля самого класса - указатель на первый узел + количество элементов. Реализованы конструкторы по умолчанию, конструктор из массива, конструктор с заданным параметром, конструктор копирования, деструктор. Реализованы основные методы - Доступ к элементам, изменение элементов, вставка и удаление элементов, информация о списке.

**DynamicArray** - Тут реализуем шаблонный класс DynamicArray, представляющий из себя динамический массив. Содержит конструкторы по умолчанию, с размером, копирование данных из существующего массива, копирование части массива, копирование существующего массива, также содержит методы доступа по индексу, измененение по индексу, возвращение текущего массива, функцию изменения размера и перегрузки операторов

**matrix.h** - Тут реализуем шаблонный класс Matrix для работы с двумерными матрицами произвольного типа T. Поля - последовательность последовательностей, количество строк, количество столбцов. Реализовны конструктор по умолчанию и конструктор с размерами. Реализованы методы доступа к элементам, сложение, умножение на скаляр, умножение на матрицу, норма матрицы.

**sequence.h** - реализует абстрактную иерархию последовательностей Sequence с двумя конкретными реализациями: ArraySequence и ListSequence. Реализоаваны методы получения элементов, установки значения, добавления элементов, вставки, конкатенации, получения подпоследовательности.

**dirgraph.h** - реализует класс для работы с ориентированными взвешенными графами. Граф представлен матрицой смежности. Реализованы методы инициализации, изменения рёбер, получение размера графа, вывод графа. Реализован алгоритм поиска пути, получения веса пути, топологической сортировки.

**graph.h** - реализует класс Graph как расширение класса dirgraph для работы с неориентированными взвешенными графами. Реализован конструктор. Каждое ребро добавляется в обе стороны матрицы смежности + запрет на топологическую сортировку.